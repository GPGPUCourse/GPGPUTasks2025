#version 450

#include <libgpu/vulkan/vk/common.vk>

#include "../defines.h"

layout (std430, binding = 0) readonly buffer MatrixAIn   { float a[]; }; // rows=h x cols=k
layout (std430, binding = 1) readonly buffer MatrixBIn   { float b[]; }; // rows=k x cols=w
layout (std430, binding = 2)          buffer MatrixCOut  { float c[]; }; // rows=h x cols=w

layout (push_constant) uniform PushConstants {
    uint w;
    uint h;
    uint k;
} params;

layout (local_size_x = GROUP_SIZE_X, local_size_y = GROUP_SIZE_Y) in;

shared float local_a[GROUP_SIZE_Y][GROUP_SIZE_X + 1];
shared float local_b[GROUP_SIZE_Y][GROUP_SIZE_X + 1];

void main()
{
    uint lx = gl_LocalInvocationID.x;
    uint ly = gl_LocalInvocationID.y;
    uint gx = gl_GlobalInvocationID.x;
    uint gy = gl_GlobalInvocationID.y;
    uint group_x = gl_WorkGroupID.x;
    uint group_y = gl_WorkGroupID.y;
    if (gx >= params.w || gy >= params.h) return;

    float sum = 0.0;
    uint n_tiles = (params.k + GROUP_SIZE_X - 1) / GROUP_SIZE_X;
    for (uint tile = 0; tile < n_tiles; tile++) {
        uint a_col = tile * GROUP_SIZE_X + lx;
        if (gy < params.h && a_col < params.k) {
            local_a[ly][lx] = a[gy * params.k + a_col];
        } else {
            local_a[ly][lx] = 0.0;
        }

        uint b_row = tile * GROUP_SIZE_Y + ly;
        if (b_row < params.k && gx < params.w) {
            local_b[ly][lx] = b[b_row * params.w + gx];
        } else {
            local_b[ly][lx] = 0.0;
        }

        barrier();

        for (uint i = 0; i < GROUP_SIZE_X; i++) {
            sum += local_a[ly][i] * local_b[i][lx];
        }

        barrier();
    }

    if (gx < params.w && gy < params.h) {
        c[gy * params.w + gx] = sum;
    }
}
