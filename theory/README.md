## Задание 1.
Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```

Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

### Ответ:
Проще всего реализовать вычисление
```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
```

### Обоснование:
Первый сигнал проще реализовать, так как для него используется нерекуррентная формула, поэтому нам достаточно в кернеле подгрузить 3 последовательных числа и сложить их. Для второго же сигнала необходимо придумывать, как вычислять его не используя рекурсию, чтобы избежать code divergence.

## Задание 2.
Предположим что размер warp/wavefront равен 32 и рабочая группа делится
на warp/wavefront-ы таким образом что внутри warp/wavefront
номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Напоминание: инструкция исполняется (пусть и отмаскированно) в каждом потоке warp/wavefront если хотя бы один поток выполняет эту инструкцию неотмаскированно. Если не все потоки выполняют эту инструкцию неотмаскированно - происходит т.н. code divergence.

Пусть размер рабочей группы (32, 32, 1)

```
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

Произойдет ли code divergence? Почему?

### Ответ:
Code divergence не произойдёт.

### Обоснование:
Code divergence происходит, когда часть потоков исполняют код неотмаскированно, а часть - отмаскированно. В данном случае в рамках одного warp get_local_id(1) выдаст одно и то же число, так как все потоки в warp'е помещаются в размер рабочей группы по x. Значение get_local_size(1) * get_local_id(0) всегда кратно 32, получаем, что idx % 32 = get_local_id(1). Выходит, что в рамках 1 warp все потоки выполнят один и тот же код неотмаскированно, поэтому code divergence не произойдёт.

## Задание 3.

Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится
на warp/wavefront-ы таким образом что внутри warp/wavefront
номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1).
Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

(a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

(b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

(c)
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

### Ответ:
(a) - обращение будет coalesced. В рамках рабочей группы произойдёт запись 32 кеш линий.

(b) - обращение не будет coalesced. В рамках рабочей группы произойдёт запись 32*32 = 1024 кеш линий.

(c) - обращение не будет coalesced. В рамках рабочей группы произойдёт запись 2*32 = 64 кеш линий.
