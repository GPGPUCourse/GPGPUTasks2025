# Теоретическое задание: параллелизуемость/code divergence/memory coalesced access

Ниже три небольших задачи. Рекомендуется хотя бы начать делать каждое задание к лекции 29 сентября, чтобы задать вопросы если они будут и обсудить задания.

Формат сдачи - письмо на ```gpucourse@yandex.ru```

 - тема письма как название PR: ```Task02 <Имя Фамилия>```
 - задания должны идти подряд - от первого к третьему
 - явно должен быть виден ```ответ```
 - должно быть объяснение ответа (рассуждение)
 - форма может быть свободной - в т.ч. любые иллюстрации если они упрощают понимание (кроме фотографии рукописного текста)

**1)** Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```

Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

**Ответ:** Первый сигнал нам удобно реализовать в модель массового параллелизма, поскольку вычисление каждого элемента y1[n] не зависит от других значений y1[i], следовательно нам несложно сделать эффективную программу, где каждый воркайтем вычисляет значение и кладет его в память по своему индексу. Здесь нет проблем ни с чтением данных, ни с проведением элементарных операций (2 сложения), ни с последующей записью в память. Во втором случае сходу впринципе не понятно, как реализовать данную реккурентную формулу в модели массового параллелизма, так как вычисление элемента на y1[n] требует доступа к данным, которые должны быть уже посчитаны другим воркайтемами и вероятно будет быстрее выполнятся на CPU (просто последовательно вычисляем элементы в цикле)

**2)** Предположим что размер warp/wavefront равен 32 и рабочая группа делится
на warp/wavefront-ы таким образом что внутри warp/wavefront
номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Напоминание: инструкция исполняется (пусть и отмаскированно) в каждом потоке warp/wavefront если хотя бы один поток выполняет эту инструкцию неотмаскированно. Если не все потоки выполняют эту инструкцию неотмаскированно - происходит т.н. code divergence.

Пусть размер рабочей группы (32, 32, 1)

```
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

Произойдет ли code divergence? Почему?

**Ответ:** Нет, не произойдет. Поскольку мы имеем размер рабочей группы (32, 32, 1), то в каком-то варпе (например, в первом) индексы воркайтемов будут иметь вид: (0, 0), (1, 0) ... (31, 0). Следовательно (также например для первого варпа для детерминированности) вычисленные индексы будут выглядеть как: 0 + 32 * 0, 0 + 32 * 1, ... 0 + 32 * 31 и после взятия остатка по модулю 32 будут равны нулю, следовательно весь варп зайдет в первое ветвление. Аналогично можно показать что для произвольного варпа с индексами воркайтемов (0, y), (1, y), ... (31, y) посчитанные индексы будут равны y + 32 * 0, y + 32 * 1, ... y + 32 * 31 и все равны y. 

**3)** Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится
на warp/wavefront-ы таким образом что внутри warp/wavefront
номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1).
Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

(a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

**Ответ:** Да, будет coalesced, 32 записей кэшлиний (уникальных - 32). Также рассмотрим один варп с индексами (0, y), (1, y), ... (31, y). Тогда воркайтемы в данном варпе пишут в память по адресам 0 + 32 * y, 1 + 32 * y. Следовательно вся запись будет происходить на участе памяти (от 0 до 31) + 32 * y. Учитывая то, что записываем мы каждый раз по 4 байта (размер флота), то один варп запишет ровно в одну кэш линию. Соответственно так как у нас 32 варпов, то получим итоговый ответ в 32 кеш линии.

(b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

**Ответ:** Нет, не будет coalesced, 1024 записей кэшлиний (уникальных - 32). Также рассмотрим один варп с индексами (0, y), (1, y), ... (31, y). Тогда воркайтемы в данном варпе пишут в память по адресам y + 32 * y, 1 + 32 * y. Следовательно каждый варп будет хотеть писать сразу в 32 кэш линии (на каждой кэшлинии в элемент с индексом y). Соответственно это вертикальный, а не горизонтальный доступ. Соответственно каждый варп будет вынужден сделать запись в 32 кэш линии и всего потребуется 32 * 32 записей кэшлиний в память.

(c)
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

**Ответ:** Нет, не будет coalesced, 64 записей кэшлиний (уникальных - 33). Также рассмотрим один варп с индексами (0, y), (1, y), ... (31, y). Тогда воркайтемы в данном варпе пишут в память по адресам 1 + 0 + 32 * y, 1 + 1 + 32 * y, ... 1 + 31 + 32 * y. Это выглядит почти как первый случай только с разницей, что мы имеем сдвиг и поэтому не умещаемся в одну кэшлинию, следовательно каждому варпу потребуются 2 кэшлинии и суммарно 32 * 2 записей кэшлиний в память
