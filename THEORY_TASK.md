# Теоретическое задание: параллелизуемость/code divergence/memory coalesced access

Формат сдачи - письмо на ```gpucourse@yandex.ru```

**1)** Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```

Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

### Ответ:

Первый. Второй сигнал использует прошлые результаты вычислений, что потребует вычислять значения $y_2[n]$ последовательно. Сигнал $y_1[n]$ проще и быстрее реализовать на GPU,
потому что он не содержит зависимостей между выходными элементами - для каждого $n$ результат можно обработать независимо.

---

**2)** Предположим что размер warp/wavefront равен 32 и рабочая группа делится
на warp/wavefront-ы таким образом, что внутри warp/wavefront
номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1)

```
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

Произойдет ли code divergence? Почему?

### Ответ:

get_local_id(0) - изменения по Х. Значение от 0 до 31.

get_local_id(1) - изменения по У. Значение от 0 до 31.

get_local_size(1) = 32.

warp - одна строка по оси X.

Получаем формулу 

idx = y + 32 * x.

Рассмотрим также выражение:

idx % 32 < 16.

idx % 32 = (y + 32 * x) % 32.

32 * x поделится на 32 без остатка. Получим

idx % 32 = y % 32.

Внутри одного warp-а y будет фиксированно. А значит, все 32 потока выполняют одну и ту же ветку (foo() или bar()). Code divergence не произойдёт.

---

**3)** Как и в прошлом задании, предположим, что размер warp/wavefront равен 32, и рабочая группа делится
на warp/wavefront-ы таким образом, что внутри warp/wavefront
номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1).
Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

(a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

### Ответ:

Да, обращение к памяти coalesced.

idx = x + 32 * y.

В пределах одного warp-а get_local_id(1) фиксированно, а x идёт подряд (0..31). Потоки в warp обращаются к последовательным элементам массива:

0 + 32 * y, 1 + 32 * y, ..., 31 + 32 * y.

В одной рабочей группе:

1. Всего 32*32 = 1024 WorkItem-ов.

2. Начинаем с границы кэш-линии - смещения нет.

3. Всего 1024/32 = 32 Warp-a.

4. Всего 32 float-a занимают 32*4 = 128 байта.

5. Размер кэш-линии - 128 байта. 

6. Одна кэш-линия на одну строку y.

7. В группе 32 строки (y=0..31) - 32 кеш-линии.

Итого: 32 кеш-линии.

---

(b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```

### Ответ:

Нет, обращение к памяти не coalesced.

idx = y + 32 * x.

Потоки в warp обращаются к элементам массива с шагом в 32 элемента:

y + 32 * 0, y + 32 * 1, ..., y + 32 * 31.

В одной рабочей группе:

1. Всего 32*32 = 1024 WorkItem-ов.

2. Каждый warp не обращается к последовательным адресам.
При выгрузке одного WorkItem-а выгружаем 32 float-a, но используем лишь одно значение (наш шаг - 32).

2. Итого 1024 Warp-a.

3. Всего 32 float-a занимают 32*4 = 128 байта.

4. Размер кэш-линии - 128 байта. 

5. Начинаем с границы кэш-линии - смещения нет.

6. Получаем, что для одной операции используем 32 кэш-линии на одну строку y.

8. В группе 32 строки (y=0..31) - 32*32 = 1024 кеш-линии.

Итого: 1024 кеш-линии.

---

(c)
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```
### Ответ:

Да, обращение к памяти coalesced.

idx = 1 + x + 32 * y.

Потоки в warp обращаются к последовательным элементам массива:

1 + 0 + 32 * y, 1 + 1 + 32 * y, ..., 1 + 31 + 32 * y.

В одной рабочей группе:

1. Всего 32*32 = 1024 WorkItem-ов.

2. Всего 32 float-a занимают 32*4 = 128 байта.

3. Размер кэш-линии - 128 байта. 

4. Есть смещение на 1 элемент - float размером 4 байта.

5. Две кэш-линии на одну строку y - 128 байта на выгрузку данных + смещение 4 байта.

6. В группе 32 строки (y=0..31) - 64 кеш-линии.

Итого: 64 кеш-линии.
