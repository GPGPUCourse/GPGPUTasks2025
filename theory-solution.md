1. Давайте поймём, что `y1` считается на GPU тривиально и довольно быстро: пусть `i`-й поток считает значение `y1[i]` по определению. Тогда для warp-а, состоящего из потоков с номерами `[i, i + 32)` нам потребуются элементы `x[i - 1], x[i], ..., x[i + 32]`. Это coalesced паттерн доступа к памяти.

    С другой стороны, каждое следующее значение `y2` зависит от двух предыдущих (а также от соответствующего значения x), поэтому просто по формуле из определения распараллелить не получится. Можно заметить, что `x[1], x[2], ..., x[i]` входят в `y[i]` с коэффициентами, равными числам Фибоначчи и пытаться распараллелить вычисление `y[i] = sum_{j <= i} x[j] * fib[i - j]`, но здесь уже `O(n^2)` вычислений, так что у меня нет идей, как это сделать так, чтобы обогнать наивное последовательное вычисление `y2`. 

    **В любом случае, вычисление `y1` на GPU точно быстрее и проще.** 

2. Так как размер рабочей группы равен `(32, 32, 1)` и чаще всего номер `workItem` меняется по оси `x`, то внутри одного warp-а (размер которого равен как раз 32) меняется только значение `x`. В частности, это означает, что внутри warp-а `get_local_id(1) = const`. 

    Кроме того, `idx` и `get_local_id(1)` сравнимы по модулю 32 (так как `get_local_size(1) = 32`), а значит `idx % 32` = const внутри warp-а, и **code divergence не произойдёт**.

3. Возможно, в задании опечатка, и нужно считать количество кэш-линий для warp-а, а не для рабочей группы. В любом случае, я сделаю и то, и другое.

    Количество кэш-линий, которые мы запишем в рабочей группе, -- это сумма количеств кэш-линий для всех её warp-ов. Так как в каждой рабочей группе 32 warp-а, то в случае, когда каждый warp записывает одинаковое количество кэш-линий (далее мы убедимся, что для всех трёх пунктов это верно), это число нужно просто умножить на 32, получим количество кэш-линий для рабочей группы. 

    (a) Внутри warp-а выражение `get_local_size(0) * get_local_id(1)` является константой и делится на 32, `get_local_id(0)` пробегает 32 последовательных значения, первое из них тоже делится на 32, тогда **для warp-а мы загрузим ровно одну кэш-линию, это обращение к памяти будет coalesced.** 

    **Тогда в рабочей группе мы загрузим 32 * 1 = 32 кэш-линии.**

    (b) Внутри warp-а get_local_id(1) = const, get_local_id(0) пробегает 32 последовательных значения, так что мы обратимся к 32 ячейкам вида 32k + b, каждая из них окажется в своей кэш-линии, **обращение к памяти будет uncoalesced**. **Тогда для warp-а мы загрузим 32 кэш-линии, а для рабочей группы 32 * 32 = 1024**.

    (c) Рассуждения такие же, как в пункте (a), но **в каждом warp-е придётся записать две кэш-линии**, поскольку для первого потока в warp-е индекс будет сравним с единицей по модулю 32. **В рабочей группе запишем 32 * 2 = 64 кэш-линии**.